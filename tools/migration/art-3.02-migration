#!/usr/bin/perl -w

use strict;

use vars qw(%header_list);
use vars qw(%library_list);

BEGIN {
  %header_list = (
    "art/Framework/Services/Optional/TFileService.h" => "art_root_io/TFileService.h",
    "art/Framework/Services/Optional/TFileDirectory.h" => "art_root_io/TFileDirectory.h",
    "art/Framework/IO/Root/checkDictionaries.h" => "art/Framework/IO/Root/checkDictionaries.h",
    "art/Framework/IO/Root/detail/DummyProductCache.h" => "art/Framework/IO/Root/detail/DummyProductCache.h",
    "art/Framework/IO/Root/detail/getObjectRequireDict.h" => "art/Framework/IO/Root/detail/getObjectRequireDict.h",
    "art/Framework/IO/Root/detail/KeptProvenance.h" => "art/Framework/IO/Root/detail/KeptProvenance.h",
    "art/Framework/IO/Root/detail/rootOutputConfigurationTools.h" => "art/Framework/IO/Root/detail/rootOutputConfigurationTools.h",
    "art/Framework/IO/Root/DropMetaData.h" => "art/Framework/IO/Root/DropMetaData.h",
    "art/Framework/IO/Root/GetFileFormatEra.h" => "art/Framework/IO/Root/GetFileFormatEra.h",
    "art/Framework/IO/Root/GetFileFormatVersion.h" => "art/Framework/IO/Root/GetFileFormatVersion.h",
    "art/Framework/IO/Root/RootDB/SQLErrMsg.h" => "art/Framework/IO/Root/RootDB/SQLErrMsg.h",
    "art/Framework/IO/Root/RootDB/SQLite3Wrapper.h" => "art/Framework/IO/Root/RootDB/SQLite3Wrapper.h",
    "art/Framework/IO/Root/RootDB/tkeyvfs.h" => "art/Framework/IO/Root/RootDB/tkeyvfs.h",
    "art/Framework/IO/Root/RootDB/TKeyVFSOpenPolicy.h" => "art/Framework/IO/Root/RootDB/TKeyVFSOpenPolicy.h",
    "art/Framework/IO/Root/RootFileBlock.h" => "art/Framework/IO/Root/RootFileBlock.h",
    "art/Framework/IO/Root/RootInput.h" => "art/Framework/IO/Root/RootInput.h",
    "art/Framework/IO/Root/RootOutputTree.h" => "art/Framework/IO/Root/RootOutputTree.h",
  );
  %library_list = (
    # Bare link-line variables
    "art_Framework_Services_Optional_TFileService_service" => "art_root_io_TFileService_service",
    "art_Framework_IO_Root" => "art_root_io",
    "art_Framework_IO_Root_detail_sources" => "art_root_io_detail",
    "art_Framework_IO_Root_RootDB" => "art_root_io_RootDB",
    "art_Framework_IO_Root_RootInput_source" => "art_root_io_RootInput_source",
    "art_Framework_IO_RootVersion" => "art_root_io",
    # CMake link-line variables
    "ART_FRAMEWORK_SERVICES_OPTIONAL_TFILESERVICE_SERVICE" => "ART_ROOT_IO_TFILESERVICE_SERVICE",
    "ART_FRAMEWORK_IO_ROOT" => "ART_ROOT_IO",
    "ART_FRAMEWORK_IO_ROOT_DETAIL_SOURCES" => "ART_ROOT_IO_DETAIL",
    "ART_FRAMEWORK_IO_ROOT_ROOTDB" => "ART_ROOT_IO_ROOTDB",
    "ART_FRAMEWORK_IO_ROOT_ROOTINPUT_SOURCE" => "ART_ROOT_IO_ROOTINPUT_SOURCE",
    "ART_FRAMEWORK_IO_ROOTVERSION" => "ART_ROOT_IO"
  );
}

use Getopt::Long qw(:config no_ignore_case bundling);

my $top_level_dir;
my $dry_run;
GetOptions("help|h|?" => \&help_message,
           "top-level-dir|d=s" => \$top_level_dir,
           "dry-run|n" => \$dry_run)
    or die_while_processing_options();

if (!defined $top_level_dir) {
    print("The 'top-level-dir|d' command-line option is required:\n  ");
    usage();
    exit(1);
}

sub usage {
    print("Usage: art-3.02-migration -d <top-level directory> [--dry-run]\n");
}

sub help_message {
    print("\n");
    usage();
    print("\nOptions:\n\n");
    print("  -d [--top-level-dir] arg   Top-level directory to apply migration script.\n");
    print("  -n [--dry-run]             Show what files would be changed.\n\n");
    exit(0);
}

sub die_while_processing_options {
    usage();
    print("Type 'art-3.02-migration --help' for more information.\n");
    exit(1);
}

sub replace_in_files {
  my ($files_ref, $old_pattern, $new_pattern, $dry) = @_;
  foreach (@{$files_ref}) {
    my $output = `sed -n "s|$old_pattern|$new_pattern|p" $_`;
    if (length $output ne 0) {
      if ($dry) {
        print "  Would change file $_";
      }
      else {
        print "  Updating file $_";
        `sed -i.backup "s|$old_pattern|$new_pattern|g" $_`;
      }
    }
  }
}

# Replace C++ header dependencies
my $cpp_files_str = `find $top_level_dir \\( \\( -name .svn -o -name .git -o -name CVS \\) -prune \\) -o \\( -name '*.c' -o -name '*.cxx' -o -name '*.cc' -o -name '*.cpp' -o -name '*.C' -o -name '*.h' -o -name '*.hxx' -o -name '*.hh' -o -name '*.hpp' -o -name '*.[it]cc' -o -name '*.H*' \\) -print`;
my @cpp_files = split /^/m, $cpp_files_str;
foreach my $old_inc (sort keys %header_list) {
  print "Checking for files using $old_inc\n";
  my $new_inc = $header_list{$old_inc};
  # This pattern also removes trailing whitespace
  my $old_pattern = '^\\(#include\\s\\+[\\"<]\\)' . $old_inc . '\\([\\">]\\)[^\\s]*$';
  my $new_pattern = '\\1' . $new_inc . '\\2';
  replace_in_files(\@cpp_files, $old_pattern, $new_pattern, $dry_run);
}

# Replace Library link lines
my $cmake_files_str = `find $top_level_dir \\( \\( -name .svn -o -name .git -o -name CVS \\) -prune \\) -o \\( -name 'CMakeLists.txt' -o -name '*.cmake' -o -name 'SConscript' \\) -print`;
my @cmake_files = split /^/m, $cmake_files_str;
foreach my $old_lib (sort keys %library_list) {
  print "Checking for uses of $old_lib\n";
  my $new_lib = $library_list{$old_lib};
  replace_in_files(\@cmake_files, $old_lib, $new_lib, $dry_run);
}
